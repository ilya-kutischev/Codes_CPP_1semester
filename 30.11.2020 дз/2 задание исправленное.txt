//В массиве А(N,M) строки расположить в порядке убывания количества минимальных элементов
//в каждой строке. Использовать функцию для определения количества минимальных элементов в каждой строке.
//Дополнительный массив не использовать.

//проблема заключалась в том, что программа не давала выводить (точнее выводила неверно) неквадратные матрицы, из-за ошибки ввода-вывода
//ввод-вывод из примеров заданий я заменил на исправленный, теперь всё работает


#include <iostream>
using namespace std;
int kolMin(int a[], int n);
const int D1 = 20, D2 = 20;
int main()
{
	setlocale(LC_ALL, "RUS");
	int i, j, N, M, a[D1][D2];
	cout << "N="; //ввод количества строк
	cin >> N;
	cout << "M="; //ввод количества столбцов
	cin >> M;
	cout << "Input matrix A \n";
	//цикл по переменной i, в которой перебираем строки матрицы
	for (i = 0; i < N; i++)
		//цикл по переменной j, в котором перебираем элементы внутри строки
		for (j = 0; j < M; j++)
			cin >> a[i][j]; //ввод очередного элемента матрицы
			
			
			int x;
		for ( i = 1; i < N; i++) //сортировка пузырьком
			for (int k = 0; k < N - i; k++)
				if (kolMin(a[k], M) < kolMin(a[k + 1], M)) {
					for ( j = 0; j < M; j++) { x = a[k][j]; a[k][j] = a[k + 1][j]; a[k + 1][j] = x; } //обмен строк
				}
	
			
			
			
			
	cout << "matrix A \n";
	for (i = 0; i < N; i++)
	{
		//цикл по переменной i, в котором перебираем строки матрицы
		for (j = 0; j < M; j++)
			cout << a[i][j] << "\t"; //вывод очередного элемента матрицы
		cout << endl; //переход на новую строку после вывода всех элементов строки
	}
	system("pause");
	return 0;}
	
	int kolMin(int a[], int n) {
	int min = a[1], kolvo = 0;

	for (int i = 0; i < n; i++) {

		if (a[i] == min)kolvo++;   //если находит подобное наименьшее- увеличивает количество

		if (a[i] < min) { min = a[i]; kolvo = 1; }//если нашлось число меньше
	}

	return kolvo;

}
